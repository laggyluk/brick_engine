unit astar3d_pathFinder;

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2502
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
{$mode objfpc}{$H+}

interface

uses
  Classes,astar3d_point3d,astar3d_breadCrumb,astar3d_minheap,
  fgl, core_types,core_chunk, core_utils, VectorTypes, VectorGeometry;
type

  TBoolMap = specialize TFPGMap<integer,boolean>;
  TCardinalList  = specialize TFPGList<cardinal>;
  { TPathFinder }

  TPathFinder = class
  public
  type
    { Surr }
    Surr = class
    public
      Point: TPoint3D;
      Cost: Integer;
    public
      constructor Create(x: Integer; y: Integer; z: Integer);
    end;
    TArrayOfSurr = array of Surr;
   private
    surrounding: TArrayOfSurr;
   public
    //use map instead of array of bools
    function FindPathList(start: TPoint3D; eend: TPoint3D; flyngAllowed,
      isJobSearch: boolean; var listLength: integer): TSearchNode;
    constructor create;
    destructor destroy;
  private
    openList :TMinHeap;
    function FindPathReversedList(start: TPoint3D; eend: TPoint3D; flyngAllowed,
      isJobSearch: boolean; var listLength: integer): TSearchNode;
  end;

implementation

{$HINTS OFF}
{$WARNINGS OFF}

constructor TPathFinder.Surr.Create(x: Integer; y: Integer; z: Integer);
begin
  inherited Create;
  Self.Point := vector3imake(x, y, z);
  Self.Cost := x * x + y * y + z * z;
end;

function TPathFinder.FindPathList(start: TPoint3D; eend: TPoint3D;
          flyngAllowed,isJobSearch:boolean;var listLength:integer): TSearchNode;
begin
  Result := FindPathReversedList( eend, start,flyngAllowed,isJobSearch,listLength);
  //eend.Destroy;
  //start.Destroy;
end;

constructor TPathFinder.create;
var x,y,z,i:integer;
begin
  //Neighbour options
  i:=0;
  setlength(surrounding,27);
  for x:=-1 to 1 do
    for y:=-1 to 1 do
      for z:=-1 to 1 do begin
        Surrounding[i]:=surr.Create(x,y,z);
        inc(i);
      end;

{
  //skip cutting corners?
  setlength(surrounding,15);
  for x:=-1 to 1 do
    for y:=-1 to 1 do
      for z:=-1 to 1 do begin
        if (x<>0) and(z<>0) then continue;
        Surrounding[i]:=surr.Create(x,y,z);
        inc(i);
      end;
         }
end;

destructor TPathFinder.destroy;
var x,y,z,i:integer;
begin
  inherited;
  //Neighbour options
  for i:=0 to length(surrounding)-1 do Surrounding[i].Destroy;
  //openList.Destroy;
end;

function posToChunkPos(v: TVector3i): TAffineVector;
begin
  result:=Vector3fMake(v[0]-world_width2,v[1],v[2]-world_depth2);
end;

//rozroznienie na jednostki chodzace i latajace (podfruwajace)
//rozroznienie na zwykle chdodzenie i chodzenie do pracy. w tym drugim przpadku
//dozwolony path ma przedostatni element mieszczacy ludzika a ostatni niekoniecznie

function TPathFinder.FindPathReversedList(start: TPoint3D; eend: TPoint3D;
  flyngAllowed,isJobSearch:boolean;var listLength:integer): TSearchNode;
type
  TArrayOfArrayOfBoolean = array of array of Boolean;
  TArrayOfBoolean = array of Boolean;
var
  node: TSearchNode;
  cost: Integer;
  pathCost: Integer;
  brWorldIdx: Integer;
  lastPos,tmp: TPoint3D;
  sur: surr;
  i: Integer;
  current,prev: TSearchNode;
  brWorld: TCardinalList;
  sz: Integer;
  sy: Integer;
  sx: Integer;
  //openList: TMinHeap;
  startNode: TSearchNode;
  steps:cardinal;
  blokOpen:boolean;

  v1,v2,v3,v4:TVector3i;
  //midBlok,grBlok,legBLok,torsoBlok,headBlok
begin
  steps:=0;
  startNode := TSearchNode.Create(start, 0, 0, nil);
  //openList.clear;
  openList := TMinHeap.Create;
  openList.Add(startNode);
  sx := world_width-2;
  sy := chunk_height-2;
  sz := world_depth-2;
  //setlength(brWorld,sx * sy * sz);
  brWorld:=TCardinalList.Create;
  brWorld.Add(start[0] + (start[1] + start[2] * sy) * sx);
  while (openList.HasNext) do
  begin
    current := openList.ExtractFirst;
    if (GetDistanceSquared(current.position,eend) <= 3) then
      begin
        //let job path end 1 step before actual end as actor doesn't need to stand
         //directly over target block
        if isJobSearch then begin
          result:=TSearchNode.Create(current.position,(current.pathCost+1),(current.cost+ 1),current);
        end else
          Result:=TSearchNode.Create(eend,(current.pathCost+1),(current.cost+ 1),current);
        brWorld.free;
        listLength:=openList.clearAndFree(result);
        Exit;
      end;
    i := 0;
    while (i < Length(surrounding)) do
    begin
      sur := surrounding[i];
      tmp := vector3imake(current.position[0]+sur.Point[0]
                          ,current.position[1]+sur.Point[1]
                          ,current.position[2]+sur.Point[2]);
      brWorldIdx := tmp[0] + (tmp[1] + tmp[2] * sy) * sx;
      blokOpen:=false;
      //check if block is 'walkable' and enough space to fit in height
      if  blokWalkable(tmp,flyngAllowed) and (brWorld.IndexOf(brWorldIdx)=-1) then blokOpen:=true;
      //allow cutting corners only in open terrain
      if (sur.Point[0]<>0) and (sur.Point[2]<>0) then begin
          v1:=vector3imake(tmp[0]-1,tmp[1]+sur.Point[1],tmp[2]);
          v2:=vector3imake(tmp[0]+1,tmp[1]+sur.Point[1],tmp[2]);
          v3:=vector3imake(tmp[0],tmp[1]+sur.Point[1],tmp[2]-1);
          v4:=vector3imake(tmp[0],tmp[1]+sur.Point[1],tmp[2]+1);
          if (not blokWalkable(v1,flyngAllowed)) or (not blokWalkable(v2,flyngAllowed))
            or (not blokWalkable(v3,flyngAllowed)) or (not blokWalkable(v4,flyngAllowed))
          then blokOpen:=false;
      end;

      if blokOpen then begin
        brWorld.insert(0,brWorldIdx);
        pathCost += (sur.Cost);
        cost := (pathCost + GetDistanceSquared(tmp,eend));
        node := TSearchNode.Create(tmp, cost, pathCost, current);
        openList.Add(node);
        //inc(steps);
      end;
      //*PostInc*/;
      i+=1;
      inc(steps)
    end;
    if (steps>maxPathSteps) then begin
      //potential mem leak? stuff might not be released
       log('TPathFinder.FindPathReversedList:: maxPathSteps reached, path not found');
       break;
    end;
  end;
  Result := nil;
  brWorld.destroy;
  startNode.destroy;
  openList.destroy;
end;

end.

